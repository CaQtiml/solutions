สำหรับข้อนี้ โดยเบื้องต้นแล้ว เราต้องรับค่ามาว่าหนังตอนที่ $i$ ต้องจ่ายราคาเท่าไหร่ 

แต่ถ้าเราอ่านโจทย์ไปเรื่อยๆจะสังเกตว่า ค่าที่โจทย์ต้องการไม่ใช่ค่าใช้จ่ายของการดูในแต่ละตอน แต่ต้องการค่าใช้จ่ายรวมที่เกิดจากการดูหลายๆตอน

ดังนั้นตอนรับข้อมูล แทนที่จะรับค่าตรงๆ ให้รับแล้ว **Quick Sum** ไปเลยจะประหยัดเวลาขึ้นมากเวลาจะเรียกค่าใช้จ่ายเมื่อลูกค้าชมสารคดีจากตอนที่ 1 ถึงตอนที่ใดๆ

ยกตัวอย่าง ถ้าค่าใช้จ่ายในการดูตอนที่ 1,2,3 เป็น 10,20,30 ตามลำดับ แทนที่จะเก็บเป็น `[10,20,30]` ก็ให้เก็บแบบ `[10,30,60]` แทน

โจทย์ต้องการให้ลูกค้าได้ดูจำนวนตอนมากที่สุดด้วยงบที่กำหนด ดังนั้นสิ่งที่เราต้องทำต่อคือ**การเรียงลำดับข้อมูล**ในอาเรย์ที่เก็บค่าจากการ Quick Sum (สำหรับโจทย์ข้อนี้ ค่าหลังการ Quick Sum ไม่ได้เรียงลำดับอัตโนมัติ เนื่องจากราคาติดลบได้) 

หลังจากนั้นเราก็ต้องทำการเช็คว่า ด้วยราคานี้จะสามารถดูได้มากที่สุดกี่ตอน 

ยกตัวอย่างเช่น สมมติให้ `[30,10,50,40]` เป็นข้อมูลที่ได้หลังการ Quick Sum ที่อธิบายว่าถ้าดู**รวม** 1 ตอนต้องใช้ 30 บาท แต่ถ้าดู**รวม** 2 ตอนจะใช้ 10 บาท เมื่อเรียงลำดับข้อมูลแล้ว (ได้เป็น `[10,30,40,50]`) จะเปลี่ยนการตีความเป็น "ถ้า 10 บาทดูได้ 2 ตอน 30 บาทก็ต้องดูได้ 2 ตอนเช่นกัน จะดูได้เพียงหนึ่งตอนไม่ได้" แทน

ส่วนสุดท้ายจะเป็นส่วนที่ให้งบประมาณของแต่ละคน แล้วโปรแกรมต้องตอบว่าดูได้มากที่สุดกี่ตอนเช่น `[10,30,40,50]` ถ้ามีงบ 35 บาทก็จะดูได้มากที่สุด 2 ตอน

ในส่วนนี้ มีสองทางเลือกในการค้นหาข้อมูล แบบแรกคือใช้ linear search แบบที่สองคือใช้ binary search (เร็วกว่าแน่นอน) ซึ่งจะเขียนด้วยตัวเองหรือจะใช้ `lower_bound()` ไม่ก็ `upper_bound()`ช่วยก็ได้

ต่อไปจะเป็นการแนะนำแนวทางการเขียนโค้ดเพิ่มเติมให้ หากอยากลองเขียนด้วยตัวเองก่อนให้หยุดอ่านที่ตรงนี้ 

ในส่วนแรกที่เก็บข้อมูลแบบ Quick Sum อาจเลือกใช้การเก็บแบบคู่ของข้อมูล(pair)แทน โดยให้ข้อมูลตัวหน้าเก็บค่าจากการทำ Quick Sumและข้อมูลตัวหลังเก็บว่าราคานี้เกิดจากการดูถึงตอนไหน

เช่นเก็บข้อมูลหลัง Quick Sum เป็น `[<30,1>,<10,2>,<50,3>,<40,4>]` แทน `[30,10,50,40]`

ที่เลือกเก็บแบบนี้เพราะหลังจากเราเรียงลำดับข้อมูล (อาจใช้ `sort()`) จะได้เป็น

`[<10,2>,<30,1>,<40,4>,<50,3>]` 

เราจะสามารถปรับเป็น

`[<10,2>,<30,2>,<40,4>,<50,4>]` 

โดยไม่ต้องพึ่งอาเรย์เสริมที่อาจต้องสร้างเพิ่มได้ ช่วยลดความสับสนตอนเขียนลง

หลังจากนั้น ถ้าจะทำการ binary search ก็ค่อยสร้างอาเรย์เสริมมาเก็บข้อมูลตัวแรกของคู่ข้อมูลทีหลังเพื่อให้ง่ายต่อการเขียนก็สามารถทำได้ในภายหลัง

Solution Code in C++ Language
```cpp
#include "bits/stdc++.h"
using namespace std;
#define ii pair<int,int>
int num[100010];
ii adj[100010];
#define f first
#define s second
int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	int n , q ;
	cin >> n >> q;

	for(int i=1;i<=n;i++)
	{
		cin >> adj[i].f;
		adj[i].f+=adj[i-1].f;
		adj[i].s=i;
	}
	sort(adj+1,adj+1+n);
	for(int i=1;i<=n;i++)
	{
		num[i] = adj[i].f;
		adj[i].s = max(adj[i-1].s , adj[i].s);
	}
	for(int i=1;i<=q;i++)
	{
		int bud;
		cin >> bud;
		int upper = upper_bound(num+1,num+1+n,bud)-(num+1);
		cout << adj[upper].s << "\n";
	}
}

```
Time Complexity : $\mathcal{O}{(qlogn)}$
